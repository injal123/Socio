// learn more about Prisma schema in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

// “Generate JavaScript code so my app can talk to the database”
generator client {
  provider = "prisma-client-js" // add -js
  output   = "../prisma/generated/client"
}

// “My database is Postgres, and its address is stored in .env”
datasource db {
  provider = "postgresql"
}

// cuid = collision-resistant uid.
model User {
  id       String @id @default(cuid()) // Prisma auto-generates a unique string, like ckz9xk3zv0001abc123.
  username String @unique
  email    String @unique
  clerkId  String @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  image    String? // '?' means optional.
  name     String?
  bio      String?
  location String?
  website  String?

  // Relations --------> [] means many, & No [] means one... (User's action).
  posts    Post[] // "One user can create many posts."
  likes    Like[] // "One user can like many posts."
  comments Comment[] // "One user can write many comments."

  followers Follows[] @relation("following") // "Many users can follow this user."
  following Follows[] @relation("follower") // "This user follows many other users."

  notifications        Notification[] @relation("userNotifications") // "Notifications received by this user."
  notificationsCreated Notification[] @relation("notificationCreator") // "Notifications created by this user."
}

model Post {
  id       String  @id @default(cuid())
  authorId String // post created by which user.
  content  String? // ? -> optional, means a post can either have content or
  image    String? // or image, or both.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  author        User           @relation(fields: [authorId], references: [id], onDelete: Cascade) // cascade delete means, if author is deleted then delete all his posts.
  likes         Like[]
  comments      Comment[]
  notifications Notification[]
}

model Comment {
  id        String   @id @default(cuid())
  authorId  String // who commented..?
  postId    String // comment on which post..?
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Reply system
  parentId String?
  parent   Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies  Comment[] @relation("CommentReplies")

  // Relations
  author        User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  post          Post           @relation(fields: [postId], references: [id], onDelete: Cascade)
  notifications Notification[]

  @@index([authorId, postId]) // composite index for faster queries.
}

model Like {
  id        String   @id @default(cuid())
  userId    String // who liked..?
  postId    String
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId]) // This prevents same user liking post twice.
  @@index([userId, postId]) // gimme the likes done by userId in this post postId.
}

model Follows {
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  // Relations
  follower  User @relation("follower", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId]) // coposite primary key to prevent duplicate follows.
  @@index([followerId, followingId]) // composite index for faster query.
}

model Notification {
  id        String   @id @default(cuid())
  userId    String // notification receiver.
  creatorId String // notification creator.
  createdAt DateTime @default(now())

  type      NotificationType
  read      Boolean          @default(false)
  postId    String?
  commentId String?

  // Relations
  user    User @relation("userNotifications", fields: [userId], references: [id], onDelete: Cascade)
  creator User @relation("notificationCreator", fields: [creatorId], references: [id], onDelete: Cascade)

  post    Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

enum NotificationType {
  LIKE
  COMMENT
  FOLLOW
}

// at the end:   npx prisma db push
// npx prisma generate
